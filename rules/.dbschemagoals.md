Database Schema goal:

üöÄ Step-by-Step: Initialize Schema

1. Enable required extension (if not already)

CREATE EXTENSION IF NOT EXISTS "pgcrypto";


‚∏ª

2. Create users table

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);


‚∏ª

3. Create user_tokens table (API access tokens)

CREATE TABLE user_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT UNIQUE NOT NULL,
  scopes TEXT[] DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT now(),
  expires_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ
);

‚ö†Ô∏è Note: You only store a hashed version of the token in this table using SHA-256.

‚∏ª

4. Create requests table (user-initiated audits)

CREATE TABLE requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  url TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  created_at TIMESTAMPTZ DEFAULT now()
);


‚∏ª

5. Create crawls table (site crawling)

CREATE TABLE crawls (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  request_id UUID REFERENCES requests(id) ON DELETE CASCADE,
  url TEXT NOT NULL,
  status TEXT DEFAULT 'pending',
  created_at TIMESTAMPTZ DEFAULT now()
);


‚∏ª

6. Create contents table (raw HTML/JS)

CREATE TABLE contents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  crawl_id UUID REFERENCES crawls(id) ON DELETE CASCADE,
  type TEXT NOT NULL, -- e.g. html / js
  content_path TEXT,
  hash TEXT,
  raw TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);


‚∏ª

7. Create scans table (scan tasks)

CREATE TABLE scans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  request_id UUID REFERENCES requests(id) ON DELETE CASCADE,
  type TEXT NOT NULL, -- e.g. secrets, xss
  status TEXT DEFAULT 'pending',
  created_at TIMESTAMPTZ DEFAULT now()
);


‚∏ª

8. Create scan_content table (scan findings)

CREATE TABLE scan_content (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  scan_id UUID REFERENCES scans(id) ON DELETE CASCADE,
  content_id UUID REFERENCES contents(id) ON DELETE CASCADE,
  finding JSONB,
  severity TEXT DEFAULT 'low'
);


‚∏ª

üîê Step 3: Enable Row-Level Security (RLS)

1. For requests

ALTER TABLE requests ENABLE ROW LEVEL SECURITY;

CREATE POLICY rls_user_owns_request
  ON requests FOR SELECT USING (
    user_id = current_setting('app.current_user')::uuid
  );


‚∏ª

2. For related tables (example: crawls)

ALTER TABLE crawls ENABLE ROW LEVEL SECURITY;

CREATE POLICY rls_user_sees_their_crawls
  ON crawls FOR SELECT USING (
    request_id IN (
      SELECT id FROM requests WHERE user_id = current_setting('app.current_user')::uuid
    )
  );

Repeat similar SELECT policies for:
	‚Ä¢	contents
	‚Ä¢	scans
	‚Ä¢	scan_content

‚∏ª

‚úÖ Final Notes
	‚Ä¢	Your backend must run:

SET app.current_user = 'user-uuid'

before executing any RLS-protected query.

	‚Ä¢	Use hashed API tokens and map them to user_id for secure authentication.