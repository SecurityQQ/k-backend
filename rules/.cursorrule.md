```yaml
# Security Audit Agent System - Cursor Rules
# Component-based architecture with clear separation of concerns

## Project Structure Rules

### Core Architecture
- Use component-based architecture: each security capability lives in `{component_name}/`
- Every component MUST have: schema.py, client.py, service.py, tools.py, agent.py, routes.py, config.py
- Shared code goes in `common/` folder
- Use OpenAI Agents SDK for all agent implementations
- Use Pydantic for all data models and validation
- Use async/await patterns throughout

### File Structure Template
```
{component_name}/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ schema.py           # All data models and types
‚îú‚îÄ‚îÄ client.py           # Backend/external API interactions
‚îú‚îÄ‚îÄ service.py          # Data serialization and business logic
‚îú‚îÄ‚îÄ tools.py            # Agent function tools (wrapped backend calls)
‚îú‚îÄ‚îÄ agent.py            # Ready-to-use agent with tools
‚îú‚îÄ‚îÄ routes.py           # API endpoints (wrapped agents + tools)
‚îî‚îÄ‚îÄ config.py           # Prompts, constants, configuration
```

## Coding Standards

### 1. Schema Design (schema.py)
- All data models and type definitions
- Use Pydantic BaseModel for all structures
- Include request/response/internal models
- Use enums for categorical data
- Pattern:
```python
from pydantic import BaseModel, HttpUrl
from typing import List, Optional
from enum import Enum

class SeverityLevel(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class {Component}Request(BaseModel):
    url: HttpUrl
    options: Optional[dict] = {}

class {Component}Finding(BaseModel):
    type: str
    severity: SeverityLevel
    location: str
    description: str
    evidence: Optional[str] = None
    confidence: float

class {Component}Response(BaseModel):
    success: bool
    findings: List[{Component}Finding]
    summary: str
    metadata: dict
```

### 2. Client Implementation (client.py)
- Handle all external API calls and backend interactions
- Pure backend operations, no business logic
- All methods are async
- Include error handling and retries
- Pattern:
```python
import aiohttp
import asyncio
from typing import Dict, Any
from .schema import {Component}Request
from .config import {COMPONENT}_CONFIG

class {Component}Client:
    """Backend client for {component_purpose}"""
    
    def __init__(self):
        self.session = None
        self.base_url = {COMPONENT}_CONFIG.api_url
        self.timeout = aiohttp.ClientTimeout(total={COMPONENT}_CONFIG.timeout)
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(timeout=self.timeout)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def {primary_operation}(self, url: str, options: dict = None) -> Dict[str, Any]:
        """Core backend operation"""
        payload = {"url": url, "options": options or {}}
        
        async with self.session.post(
            f"{self.base_url}/{endpoint}",
            json=payload,
            headers=self._get_headers()
        ) as response:
            response.raise_for_status()
            return await response.json()
    
    def _get_headers(self) -> Dict[str, str]:
        return {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "User-Agent": "{COMPONENT}_CLIENT/1.0"
        }
```

### 3. Service Implementation (service.py)
- Serialization and data transformation layer
- Business logic and data processing
- Converts between client responses and schema models
- Pattern:
```python
from typing import List
from .client import {Component}Client
from .schema import {Component}Request, {Component}Response, {Component}Finding
from .config import {COMPONENT}_PATTERNS
import re

class {Component}Service:
    """Service layer for {component_purpose} - handles serialization and business logic"""
    
    def __init__(self):
        self.client = {Component}Client()
    
    async def process_{component_action}(self, request: {Component}Request) -> {Component}Response:
        """Main service method - processes request and returns structured response"""
        async with self.client as client:
            # Get raw data from backend
            raw_data = await client.{primary_operation}(str(request.url), request.options)
            
            # Process and serialize data
            findings = self._extract_findings(raw_data, str(request.url))
            summary = self._generate_summary(findings)
            metadata = self._extract_metadata(raw_data)
            
            return {Component}Response(
                success=True,
                findings=findings,
                summary=summary,
                metadata=metadata
            )
    
    def _extract_findings(self, raw_data: dict, url: str) -> List[{Component}Finding]:
        """Extract and serialize findings from raw backend data"""
        findings = []
        content = raw_data.get('content', '')
        
        for pattern_name, pattern in {COMPONENT}_PATTERNS.items():
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                findings.append({Component}Finding(
                    type=pattern_name,
                    severity=self._determine_severity(pattern_name),
                    location=f"Position {match.start()}-{match.end()}",
                    description=f"Found {pattern_name} pattern",
                    evidence=match.group()[:50] + "..." if len(match.group()) > 50 else match.group(),
                    confidence=0.9
                ))
        
        return findings
    
    def _generate_summary(self, findings: List[{Component}Finding]) -> str:
        """Generate human-readable summary"""
        if not findings:
            return "No issues found"
        
        critical = len([f for f in findings if f.severity == "critical"])
        high = len([f for f in findings if f.severity == "high"])
        
        return f"Found {len(findings)} issues: {critical} critical, {high} high severity"
    
    def _determine_severity(self, pattern_name: str) -> str:
        """Determine severity based on pattern type"""
        severity_mapping = {
            "aws_key": "critical",
            "github_token": "critical",
            "api_key": "high",
            "password": "medium"
        }
        return severity_mapping.get(pattern_name.lower(), "low")
    
    def _extract_metadata(self, raw_data: dict) -> dict:
        """Extract metadata from raw response"""
        return {
            "scan_time": raw_data.get('timestamp'),
            "pages_scanned": raw_data.get('pages_count', 1),
            "response_time": raw_data.get('response_time')
        }
```

### 4. Tools Implementation (tools.py)
- Wrapper functions for agents
- Bridge between agents and services
- Return human-readable strings for agent consumption
- Pattern:
```python
from agents import function_tool
from .service import {Component}Service
from .schema import {Component}Request

# Initialize service
service = {Component}Service()

@function_tool
async def {primary_tool_name}(url: str, deep_scan: bool = False) -> str:
    """
    {Tool description for agent}
    
    Args:
        url: Target URL to scan
        deep_scan: Whether to perform deep analysis
    
    Returns:
        Human-readable summary of findings
    """
    options = {"deep_scan": deep_scan} if deep_scan else {}
    request = {Component}Request(url=url, options=options)
    
    try:
        response = await service.process_{component_action}(request)
        
        if not response.findings:
            return f"‚úÖ No {component_purpose} issues found at {url}"
        
        # Format for agent consumption
        result = f"üö® {component_purpose.title()} Scan Results for {url}:\n"
        result += f"{response.summary}\n\n"
        
        for finding in response.findings[:5]:  # Limit for readability
            result += f"‚Ä¢ {finding.severity.upper()}: {finding.description}\n"
            if finding.evidence:
                result += f"  Evidence: {finding.evidence}\n"
        
        if len(response.findings) > 5:
            result += f"\n... and {len(response.findings) - 5} more findings"
        
        return result
        
    except Exception as e:
        return f"‚ùå Error during {component_purpose} scan: {str(e)}"

@function_tool
async def {secondary_tool_name}(url: str, pattern_type: str = "all") -> str:
    """
    {Secondary tool description}
    """
    # Implementation for secondary functionality
    pass
```

### 5. Agent Implementation (agent.py)
- Ready-to-use agent with all component tools
- Clear instructions and persona
- Imports tools from tools.py
- Pattern:
```python
from agents import Agent
from .tools import {primary_tool_name}, {secondary_tool_name}
from .config import {COMPONENT}_AGENT_INSTRUCTIONS

{component_name}_agent = Agent(
    name="{Component}Agent",
    instructions={COMPONENT}_AGENT_INSTRUCTIONS,
    tools=[{primary_tool_name}, {secondary_tool_name}]
)

# Export for easy import
__all__ = ["{component_name}_agent"]
```

### 6. Routes Implementation (routes.py)
- FastAPI endpoints wrapping agents and tools
- Direct tool access endpoints
- Agent conversation endpoints
- Pattern:
```python
from fastapi import APIRouter, HTTPException
from agents import Runner, SQLiteSession
from .schema import {Component}Request, {Component}Response
from .service import {Component}Service
from .agent import {component_name}_agent
from .tools import {primary_tool_name}

router = APIRouter(prefix="/{component_name}", tags=["{component_name}"])

# Direct service endpoint
@router.post("/scan", response_model={Component}Response)
async def {component_name}_scan(request: {Component}Request):
    """
    Direct {component_purpose} scanning endpoint
    """
    try:
        service = {Component}Service()
        return await service.process_{component_action}(request)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Tool endpoint
@router.post("/tool/{tool_name}")
async def {component_name}_tool(tool_name: str, url: str, **kwargs):
    """
    Direct tool access endpoint
    """
    try:
        if tool_name == "{primary_tool_name}":
            result = await {primary_tool_name}(url, **kwargs)
        else:
            raise ValueError(f"Unknown tool: {tool_name}")
        
        return {"result": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Agent conversation endpoint
@router.post("/agent")
async def {component_name}_agent_chat(message: str, session_id: str = None):
    """
    Chat with {component_purpose} agent
    """
    try:
        session = SQLiteSession(session_id or f"{component_name}_session")
        result = await Runner.run({component_name}_agent, message, session=session)
        return {"response": result.final_output, "session_id": session.session_id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### 7. Configuration (config.py)
- All prompts, constants, and configuration
- Environment variables and settings
- Patterns and rules
- Pattern:
```python
import os
from typing import Dict, List
from pydantic_settings import BaseSettings

class {Component}Config(BaseSettings):
    """Configuration for {component_purpose}"""
    
    # API Configuration
    api_url: str = "https://default-api.com"
    api_key: str = os.getenv("{COMPONENT}_API_KEY", "")
    timeout: int = 30
    max_retries: int = 3
    
    # Component-specific settings
    max_findings: int = 100
    confidence_threshold: float = 0.7
    
    class Config:
        env_prefix = "{COMPONENT}_"
        env_file = ".env"

# Global config instance
{COMPONENT}_CONFIG = {Component}Config()

# Agent Instructions
{COMPONENT}_AGENT_INSTRUCTIONS = """
You are a specialized {component_purpose} security expert.

Your role:
- Analyze websites and web applications for {specific_vulnerabilities}
- Provide clear, actionable security recommendations
- Prioritize findings by severity and impact
- Explain technical issues in understandable terms

Guidelines:
- Always scan thoroughly using available tools
- Report findings with evidence and context
- Suggest specific remediation steps
- Be concise but comprehensive in your analysis

When scanning:
1. Start with basic scans to get an overview
2. Use deep scanning for detailed analysis
3. Focus on high-severity issues first
4. Provide clear next steps for remediation
"""

# Security Patterns
{COMPONENT}_PATTERNS: Dict[str, str] = {
    "aws_access_key": r"AKIA[0-9A-Z]{16}",
    "github_token": r"ghp_[0-9a-zA-Z]{36}",
    "openai_key": r"sk-[0-9a-zA-Z]{48}",
    "stripe_key": r"sk_live_[0-9a-zA-Z]{24}",
    "jwt_token": r"eyJ[0-9a-zA-Z_-]*\.eyJ[0-9a-zA-Z_-]*\.[0-9a-zA-Z_-]*",
    "private_key": r"-----BEGIN PRIVATE KEY-----",
    "api_key_generic": r"api[_-]?key['\"]?\s*[:=]\s*['\"]?[0-9a-zA-Z]{32,}",
}

# Severity Mappings
SEVERITY_MAPPING: Dict[str, str] = {
    "aws_access_key": "critical",
    "github_token": "critical", 
    "openai_key": "critical",
    "stripe_key": "critical",
    "jwt_token": "high",
    "private_key": "critical",
    "api_key_generic": "high",
}

# Response Templates
RESPONSE_TEMPLATES: Dict[str, str] = {
    "no_findings": "‚úÖ No {component_purpose} vulnerabilities detected",
    "findings_found": "üö® Found {count} {component_purpose} issues",
    "critical_alert": "üî• CRITICAL: {description}",
    "error_occurred": "‚ùå Scan failed: {error}",
}

# Export all configurations
__all__ = [
    "{COMPONENT}_CONFIG",
    "{COMPONENT}_AGENT_INSTRUCTIONS", 
    "{COMPONENT}_PATTERNS",
    "SEVERITY_MAPPING",
    "RESPONSE_TEMPLATES"
]
```

## Component Examples

### Example: scan_secrets component
```
scan_secrets/
‚îú‚îÄ‚îÄ schema.py          # SecretScanRequest, SecretFinding, SecretScanResponse
‚îú‚îÄ‚îÄ client.py          # External API calls for content fetching
‚îú‚îÄ‚îÄ service.py         # Secret detection logic and serialization
‚îú‚îÄ‚îÄ tools.py           # scan_for_secrets, check_specific_secret tools
‚îú‚îÄ‚îÄ agent.py           # Secret scanning specialist agent
‚îú‚îÄ‚îÄ routes.py          # /scan_secrets endpoints
‚îî‚îÄ‚îÄ config.py          # Secret patterns, prompts, severity rules
```

### Example: crawl_website component
```
crawl_website/
‚îú‚îÄ‚îÄ schema.py          # CrawlRequest, PageData, CrawlResponse
‚îú‚îÄ‚îÄ client.py          # Browserless/Selenium backend calls
‚îú‚îÄ‚îÄ service.py         # URL processing and data extraction
‚îú‚îÄ‚îÄ tools.py           # crawl_site, extract_forms, find_endpoints tools
‚îú‚îÄ‚îÄ agent.py           # Web crawling specialist agent
‚îú‚îÄ‚îÄ routes.py          # /crawl_website endpoints
‚îî‚îÄ‚îÄ config.py          # Crawl limits, browser settings, prompts
```

## File Naming Conventions
- Components: snake_case (scan_secrets, crawl_website)
- Classes: PascalCase (SecretScanService, CrawlWebsiteAgent)
- Files: exactly as specified (schema.py, client.py, etc.)
- Constants: UPPER_SNAKE_CASE

## Import Organization
1. Standard library imports
2. Third-party imports (agents, pydantic, aiohttp, etc.)
3. Common/shared imports
4. Local component imports

## Documentation Requirements
- Every class and method includes docstring with purpose
- Complex business logic includes inline comments
- Include type hints for all parameters and returns
- Configuration includes usage examples

When implementing a new security component:
1. Create component folder with all 7 required files
2. Define schema.py with all data models
3. Implement client.py for backend operations
4. Build service.py for business logic and serialization
5. Create tools.py with agent function wrappers
6. Configure agent.py with tools and instructions
7. Set up routes.py with all endpoint types
8. Define config.py with all constants and prompts
```